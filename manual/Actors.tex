\section{Actors}
\label{actors}

\lib provides several actor implementations, each covering a particular use case.
Most notably, actors differ in three characteristics: (1) dynamically or statically typed, (2) class-based or function-based, and (3) event-based or using blocking receives.
These three characteristics can be combined freely.
For example, an actor can be dynamically typed, implemented as a class and use blocking receives.
In any case, \lstinline^local_actor^ is the common base class for all user-defined actors.

Dynamically typed actors are more familiar to developers coming from Erlang or Akka.
They (usually) enable faster prototyping but require extensive unit testing.
Statically typed actors require more source code but enable the compiler to verify communication between actors.
Since CAF supports both, however, developers can freely mix both kinds of actors to get the best of both worlds.
A good rule of thumb is to make use of statically typing for actors that are visible across multiple translation units.



Hence, \lstinline^local_actor^ provides a common interface for actor operations like trapping exit messages or finishing execution.
The default actor implementation in \lib is event-based.
Event-based actors have a very small memory footprint and are thus very lightweight and scalable.
Context-switching actors are used for actors that make use of the blocking API (see \S\,\ref{blocking-api}), but do not need to run in a separate thread.
Context-switching and event-based actors are scheduled cooperatively in a thread pool.
Thread-mapped actors can be used to opt-out of this cooperative scheduling.

\subsection{Implicit \texttt{self} Pointer}

When using a function or functor to implement an actor, the first argument \emph{can} be used to capture a pointer to the actor itself.
The type of this pointer is \lstinline^event_based_actor*^ per default and \lstinline^blocking_actor*^ when using the \lstinline^blocking_api^ flag.
When dealing with typed actors, the types are \lstinline^typed_event_based_actor<...>*^ and \lstinline^typed_blocking_actor<...>*^.

\clearpage
\subsection{API of \texttt{local\_actor}}
\label{interface}

\begin{lstlisting}
class local_actor;
\end{lstlisting}

{\small
\begin{tabular*}{\textwidth}{m{0.45\textwidth}m{0.5\textwidth}}
  \multicolumn{2}{m{\linewidth}}{\large{\textbf{Member functions}}\vspace{3pt}} \\
  \\
  \multicolumn{2}{l}{\textbf{Observers}\vspace{3pt}} \\
  \hline
  \lstinline^actor_addr address()^ & Returns the address of this actor \\
  \hline
  \lstinline^bool trap_exit()^ & Checks whether this actor traps exit messages \\
  \hline
  \lstinline^message& current_message()^ & Returns the currently processed message\newline\textbf{Warning}: Only set during callback invocation; calling this function after forwarding the message or while not in a callback is undefined behavior \\
  \hline
  \lstinline^actor_addr& current_sender()^ & Returns the sender of the current message\newline\textbf{Warning}: Only set during callback invocation; calling this function after forwarding the message or while not in a callback is undefined behavior \\
  \hline
  \lstinline^vector<group> joined_groups()^ & Returns all subscribed groups \\
  \hline
  \\
  \multicolumn{2}{l}{\textbf{Modifiers}\vspace{3pt}} \\
  \hline
  \lstinline^quit(uint32_t reason = normal)^ & Finishes execution of this actor \\
  \hline
  \lstinline^void trap_exit(bool enabled)^ & Enables or disables trapping of exit messages \\
  \hline
  \lstinline^void join(const group& g)^ & Subscribes to group \lstinline^g^ \\
  \hline
  \lstinline^void leave(const group& g)^ & Unsubscribes group \lstinline^g^ \\
  \hline
  \lstinline^void on_sync_failure(auto fun)^ & Sets a handler, i.e., a functor taking no arguments, for unexpected synchronous response messages (default action is to kill the actor for reason \lstinline^unhandled_sync_failure^) \\
  \hline
  \lstinline^void monitor(actor whom)^ & Unidirectionally monitors \lstinline^whom^ (see Section \ref{management-monitors}) \\
  \hline
  \lstinline^void demonitor(actor whom)^ & Removes a monitor from \lstinline^whom^ \\
  \hline
  \lstinline^bool has_sync_failure_handler()^ & Checks whether this actor has a user-defined sync failure handler \\
  \hline
  \lstinline^template <class F>^ \lstinline^void set_exception_handler(F f)^ & Sets a custom handler for uncaught exceptions \\
  \hline
  \lstinline^void on_exit()^ & Can be overridden to add cleanup code that runs after an actor finished execution, e.g., to break cycles \\
  \hline
\end{tabular*}
}

\subsection{Class-based Design}

\subsection{Function-based Design}
