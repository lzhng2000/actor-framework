\section{Pattern Matching}
\label{pattern-matching}

Actor programming implies a message passing paradigm.
This means that defining message handlers is a recurring task.
The easiest and most natural way to specify such message handlers is pattern matching.
Unfortunately, C++ does not provide any pattern matching facilities.
%A general pattern matching solution for arbitrary data structures would require a language extension.
Hence, we provide an internal domain-specific language to match incoming messages.

\subsection{Basics}
\label{pattern-matching-basics}

Actors can store a set of message callbacks using either \lstinline^behavior^ or \lstinline^message_handler^.
The difference between the two is that the former stores an optional timeout.
The most basic way to define a pattern is to store a set of lambda expressions using one of the two container types.

\begin{lstlisting}
behavior bhvr1{
  [](int i) { /*...*/ },
  [](int i, float f) { /*...*/ },
  [](int a, int b, int c) { /*...*/ }
};
\end{lstlisting}

In our first example, \lstinline^bhvr1^ models a pattern accepting messages that consist of either exactly one \lstinline^int^, or one \lstinline^int^ followed by a \lstinline^float^, or three \lstinline^int^s.
Any other message is not matched and will remain in the mailbox until it is consumed eventually.
This caching mechanism allows actors to ignore messages until a state change replaces its message handler.
However, this can lead to a memory leak if an actor receives messages it handles in no state.
To allow actors to specify a default message handlers for otherwise unmatched messages, \lib provides \lstinline^others^.

\begin{lstlisting}
behavior bhvr2{
  [](int i) { /*...*/ },
  [](int i, float f) { /*...*/ },
  [](int a, int b, int c) { /*...*/ },
  others >> [] { /*...*/ }
};
\end{lstlisting}

Please note the change in syntax for the catch-all case.
The lambda expression passed to the constructor of \lstinline^behavior^ is prefixed by a ''match expression'' and the operator \lstinline^>>^.

\clearpage
\subsection{Atoms}
\label{atoms}

Assume an actor provides a mathematical service for integers.
It takes two arguments, performs a predefined operation and returns the result.
It cannot determine an operation, such as multiply or add, by receiving two operands.
Thus, the operation must be encoded into the message.
The Erlang programming language introduced an approach to use non-numerical
constants, so-called \textit{atoms}, which have an unambiguous, special-purpose type and do not have the runtime overhead of string constants.
Atoms are mapped to integer values at compile time in \lib.
This mapping is guaranteed to be collision-free and invertible, but limits atom literals to ten characters and prohibits special characters.
Legal characters are ``\lstinline[language=C++]^_0-9A-Za-z^'' and the whitespace character.
Atoms are created using the \lstinline^constexpr^ function \lstinline^atom^, as the following example illustrates.

\begin{lstlisting}
atom_value a1 = atom("add");
atom_value a2 = atom("multiply");
// ...
\end{lstlisting}

\textbf{Warning}: The compiler cannot enforce the restrictions at compile time, except for a length check.
The assertion \lstinline^atom("!?") != atom("?!")^ is not true, because each invalid character is mapped to the whitespace character.

\subsection{Atom Constants}

An \lstinline^atom_value^ alone does not help us statically annotate function handlers.
To accomplish this, \lib offers compile-time \emph{atom constants}.

\begin{lstlisting}
using add_atom = atom_constant<atom("add")>;
using multiply_atom = atom_constant<atom("multiply")>;
\end{lstlisting}

Using the constants, we can now define message passing interfaces in a convenient way.
\begin{lstlisting}
behavior do_math{
  [](add_atom, int a, int b) {
    return a + b;
  },
  [](multiply_atom, int a, int b) {
    return a * b;
  }
};
\end{lstlisting}

Atom constants define a static member \lstinline^value^ that can be used on the caller side (see \S\,\ref{send}), e.g., \lstinline^send(math_actor, add_atom::value, 1, 2)^.
Please note that the static \lstinline^value^ member does \emph{not} have the type \lstinline^atom_value^, unlike \lstinline^std::integral_constant^ for example.